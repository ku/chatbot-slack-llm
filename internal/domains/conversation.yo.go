// Code generated by yo. DO NOT EDIT.
// Package domains contains the types.
package domains

import (
	"context"
	"fmt"
	"time"

	"github.com/ku/chatbot-slack-llm/messagestore"

	"cloud.google.com/go/spanner"
	"google.golang.org/api/iterator"
	"google.golang.org/grpc/codes"
)

// Conversation represents a row from 'Conversations'.
type Conversation struct {
	ConversationID   int64     `spanner:"ConversationID" json:"ConversationID"`     // ConversationID
	ParentUserID     string    `spanner:"ParentUserID" json:"ParentUserID"`         // ParentUserID
	Text             string    `spanner:"Text" json:"Text"`                         // Text
	MessageTimestamp string    `spanner:"MessageTimestamp" json:"MessageTimestamp"` // MessageTimestamp
	ThreadTimestamp  string    `spanner:"ThreadTimestamp" json:"ThreadTimestamp"`   // ThreadTimestamp
	ThreadID         string    `spanner:"ThreadID" json:"ThreadID"`                 // ThreadID
	Channel          string    `spanner:"Channel" json:"Channel"`                   // Channel
	CreatedAt        time.Time `spanner:"CreatedAt" json:"CreatedAt"`               // CreatedAt
}

func (c *Conversation) IsMentionAt(id string) bool {
	return messagestore.MentionAt(c.Text) == id
}

var _ messagestore.Message = (*Conversation)(nil)

func ConversationPrimaryKeys() []string {
	return []string{
		"ConversationID",
	}
}

func ConversationColumns() []string {
	return []string{
		"ConversationID",
		"ParentUserID",
		"Text",
		"MessageTimestamp",
		"ThreadTimestamp",
		"ThreadID",
		"Channel",
		"CreatedAt",
	}
}

func (c *Conversation) columnsToPtrs(cols []string, customPtrs map[string]interface{}) ([]interface{}, error) {
	ret := make([]interface{}, 0, len(cols))
	for _, col := range cols {
		if val, ok := customPtrs[col]; ok {
			ret = append(ret, val)
			continue
		}

		switch col {
		case "ConversationID":
			ret = append(ret, &c.ConversationID)
		case "ParentUserID":
			ret = append(ret, &c.ParentUserID)
		case "Text":
			ret = append(ret, &c.Text)
		case "MessageTimestamp":
			ret = append(ret, &c.MessageTimestamp)
		case "ThreadTimestamp":
			ret = append(ret, &c.ThreadTimestamp)
		case "ThreadID":
			ret = append(ret, &c.ThreadID)
		case "Channel":
			ret = append(ret, &c.Channel)
		case "CreatedAt":
			ret = append(ret, &c.CreatedAt)
		default:
			return nil, fmt.Errorf("unknown column: %s", col)
		}
	}
	return ret, nil
}

func (c *Conversation) columnsToValues(cols []string) ([]interface{}, error) {
	ret := make([]interface{}, 0, len(cols))
	for _, col := range cols {
		switch col {
		case "ConversationID":
			ret = append(ret, c.ConversationID)
		case "ParentUserID":
			ret = append(ret, c.ParentUserID)
		case "Text":
			ret = append(ret, c.Text)
		case "MessageTimestamp":
			ret = append(ret, c.MessageTimestamp)
		case "ThreadTimestamp":
			ret = append(ret, c.ThreadTimestamp)
		case "ThreadID":
			ret = append(ret, c.ThreadID)
		case "Channel":
			ret = append(ret, c.Channel)
		case "CreatedAt":
			ret = append(ret, c.CreatedAt)
		default:
			return nil, fmt.Errorf("unknown column: %s", col)
		}
	}

	return ret, nil
}

// newConversation_Decoder returns a decoder which reads a row from *spanner.Row
// into Conversation. The decoder is not goroutine-safe. Don't use it concurrently.
func newConversation_Decoder(cols []string) func(*spanner.Row) (*Conversation, error) {
	customPtrs := map[string]interface{}{}

	return func(row *spanner.Row) (*Conversation, error) {
		var c Conversation
		ptrs, err := c.columnsToPtrs(cols, customPtrs)
		if err != nil {
			return nil, err
		}

		if err := row.Columns(ptrs...); err != nil {
			return nil, err
		}

		return &c, nil
	}
}

// Insert returns a Mutation to insert a row into a table. If the row already
// exists, the write or transaction fails.
func (c *Conversation) Insert(ctx context.Context) *spanner.Mutation {
	return spanner.Insert("Conversations", ConversationColumns(), []interface{}{
		c.ConversationID, c.ParentUserID, c.Text, c.MessageTimestamp, c.ThreadTimestamp, c.ThreadID, c.Channel, c.CreatedAt,
	})
}

// Update returns a Mutation to update a row in a table. If the row does not
// already exist, the write or transaction fails.
func (c *Conversation) Update(ctx context.Context) *spanner.Mutation {
	return spanner.Update("Conversations", ConversationColumns(), []interface{}{
		c.ConversationID, c.ParentUserID, c.Text, c.MessageTimestamp, c.ThreadTimestamp, c.ThreadID, c.Channel, c.CreatedAt,
	})
}

// InsertOrUpdate returns a Mutation to insert a row into a table. If the row
// already exists, it updates it instead. Any column values not explicitly
// written are preserved.
func (c *Conversation) InsertOrUpdate(ctx context.Context) *spanner.Mutation {
	return spanner.InsertOrUpdate("Conversations", ConversationColumns(), []interface{}{
		c.ConversationID, c.ParentUserID, c.Text, c.MessageTimestamp, c.ThreadTimestamp, c.ThreadID, c.Channel, c.CreatedAt,
	})
}

// UpdateColumns returns a Mutation to update specified columns of a row in a table.
func (c *Conversation) UpdateColumns(ctx context.Context, cols ...string) (*spanner.Mutation, error) {
	// add primary keys to columns to update by primary keys
	colsWithPKeys := append(cols, ConversationPrimaryKeys()...)

	values, err := c.columnsToValues(colsWithPKeys)
	if err != nil {
		return nil, newErrorWithCode(codes.InvalidArgument, "Conversation.UpdateColumns", "Conversations", err)
	}

	return spanner.Update("Conversations", colsWithPKeys, values), nil
}

// FindConversation gets a Conversation by primary key
func FindConversation(ctx context.Context, db YORODB, conversationID int64) (*Conversation, error) {
	key := spanner.Key{conversationID}
	row, err := db.ReadRow(ctx, "Conversations", key, ConversationColumns())
	if err != nil {
		return nil, newError("FindConversation", "Conversations", err)
	}

	decoder := newConversation_Decoder(ConversationColumns())
	c, err := decoder(row)
	if err != nil {
		return nil, newErrorWithCode(codes.Internal, "FindConversation", "Conversations", err)
	}

	return c, nil
}

// ReadConversation retrieves multiples rows from Conversation by KeySet as a slice.
func ReadConversation(ctx context.Context, db YORODB, keys spanner.KeySet) ([]*Conversation, error) {
	var res []*Conversation

	decoder := newConversation_Decoder(ConversationColumns())

	rows := db.Read(ctx, "Conversations", keys, ConversationColumns())
	err := rows.Do(func(row *spanner.Row) error {
		c, err := decoder(row)
		if err != nil {
			return err
		}
		res = append(res, c)

		return nil
	})
	if err != nil {
		return nil, newErrorWithCode(codes.Internal, "ReadConversation", "Conversations", err)
	}

	return res, nil
}

// Delete deletes the Conversation from the database.
func (c *Conversation) Delete(ctx context.Context) *spanner.Mutation {
	values, _ := c.columnsToValues(ConversationPrimaryKeys())
	return spanner.Delete("Conversations", spanner.Key(values))
}

// FindConversationsByThreadTimestampCreatedAt retrieves multiple rows from 'Conversations' as a slice of Conversation.
//
// Generated from index 'ConversationsByThreadID'.
func FindConversationsByThreadTimestampCreatedAt(ctx context.Context, db YORODB, threadTimestamp string, createdAt time.Time) ([]*Conversation, error) {
	const sqlstr = "SELECT " +
		"ConversationID, ParentUserID, Text, MessageTimestamp, ThreadTimestamp, ThreadID, Channel, CreatedAt " +
		"FROM Conversations@{FORCE_INDEX=ConversationsByThreadID} " +
		"WHERE ThreadTimestamp = @param0 AND CreatedAt = @param1"

	stmt := spanner.NewStatement(sqlstr)
	stmt.Params["param0"] = threadTimestamp
	stmt.Params["param1"] = createdAt

	decoder := newConversation_Decoder(ConversationColumns())

	// run query
	YOLog(ctx, sqlstr, threadTimestamp, createdAt)
	iter := db.Query(ctx, stmt)
	defer iter.Stop()

	// load results
	res := []*Conversation{}
	for {
		row, err := iter.Next()
		if err != nil {
			if err == iterator.Done {
				break
			}
			return nil, newError("FindConversationsByThreadTimestampCreatedAt", "Conversations", err)
		}

		c, err := decoder(row)
		if err != nil {
			return nil, newErrorWithCode(codes.Internal, "FindConversationsByThreadTimestampCreatedAt", "Conversations", err)
		}

		res = append(res, c)
	}

	return res, nil
}

// FindConversationsByThreadTimestampCreatedAtWithLimit retrieves multiple rows from 'Conversations' as a slice of Conversation with limit.
//
// Generated from index 'ConversationsByThreadID'.
func FindConversationsByThreadTimestampCreatedAtWithLimit(ctx context.Context, db YORODB, threadTimestamp string, createdAt time.Time, limit int) ([]*Conversation, error) {
	sqlstr := "SELECT " +
		"ConversationID, ParentUserID, Text, MessageTimestamp, ThreadTimestamp, ThreadID, Channel, CreatedAt " +
		"FROM Conversations@{FORCE_INDEX=ConversationsByThreadID} " +
		"WHERE ThreadTimestamp = @param0 AND CreatedAt = @param1"
	sqlstr += " LIMIT @limit "

	stmt := spanner.NewStatement(sqlstr)
	stmt.Params["param0"] = threadTimestamp
	stmt.Params["param1"] = createdAt
	stmt.Params["limit"] = limit

	decoder := newConversation_Decoder(ConversationColumns())

	// run query
	YOLog(ctx, sqlstr, threadTimestamp, createdAt)
	iter := db.Query(ctx, stmt)
	defer iter.Stop()

	// load results
	res := []*Conversation{}
	for {
		row, err := iter.Next()
		if err != nil {
			if err == iterator.Done {
				break
			}
			return nil, newError("FindConversationsByThreadTimestampCreatedAt", "Conversations", err)
		}

		c, err := decoder(row)
		if err != nil {
			return nil, newErrorWithCode(codes.Internal, "FindConversationsByThreadTimestampCreatedAt", "Conversations", err)
		}

		res = append(res, c)
	}

	return res, nil
}

// ReadConversationsByThreadTimestampCreatedAt retrieves multiples rows from 'Conversations' by KeySet as a slice.
//
// This does not retrives all columns of 'Conversations' because an index has only columns
// used for primary key, index key and storing columns. If you need more columns, add storing
// columns or Read by primary key or Query with join.
//
// Generated from unique index 'ConversationsByThreadID'.
func ReadConversationsByThreadTimestampCreatedAt(ctx context.Context, db YORODB, keys spanner.KeySet) ([]*Conversation, error) {
	var res []*Conversation
	columns := []string{
		"ConversationID",
		"ThreadTimestamp",
		"CreatedAt",
	}

	decoder := newConversation_Decoder(columns)

	rows := db.ReadUsingIndex(ctx, "Conversations", "ConversationsByThreadID", keys, columns)
	err := rows.Do(func(row *spanner.Row) error {
		c, err := decoder(row)
		if err != nil {
			return err
		}
		res = append(res, c)

		return nil
	})
	if err != nil {
		return nil, newErrorWithCode(codes.Internal, "ReadConversationsByThreadTimestampCreatedAt", "Conversations", err)
	}

	return res, nil
}
